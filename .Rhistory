qq <-
paste0('[out:xml][timeout:25]; \n( \n',
q1,
'); \nout body; \n>; \nout skel qt;')
oo <- overpass_query(qq)
return(oo)
}
check_residental_coverage <- function(lat, lon, meter) {
lat1 <- as.numeric(lat - (180 / pi) * (meter / 6378137))
lon1 <-
as.numeric(lon - (180 / pi) * (meter / 6378137) / cos(lat1))
lat2 <- as.numeric(lat + (180 / pi) * (meter / 6378137))
lon2 <-
as.numeric(lon + (180 / pi) * (meter / 6378137) / cos(lat2))
bb <- c(lat1, lon1, lat2, lon2)
bbstring <- paste(bb, collapse = ",")
vv <- "residential"
q1 <-
paste0('  way["highway"="', vv, '"](', bbstring, ');', collapse = '\n')
qq <-
paste0('[out:xml][timeout:25]; \n( \n',
q1,
'); \nout body; \n>; \nout skel qt;')
oo <- overpass_query(qq)
if (is.null(oo)) {
rt <- 0
} else {
rt <- (length(oo@data$highway) / meter) * 10
}
return(rt)
}
check_residental_coverage(session_geo$lat[1], session_geo$lon[1], 1000)
#devtools::install_github("hrbrmstr/overpass")
library(overpass)
#devtools::install_github("hrbrmstr/overpass")
library(overpass)
#devtools::install_github("hrbrmstr/overpass")
library(overpass)
library(osmdata)
library(sp)
library(vroom)
session_geo <- vroom("data/session_geo.csv")
check_oo <- function(lat, lon, meter) {
lat1 <- as.numeric(lat - (180 / pi) * (meter / 6378137))
lon1 <-
as.numeric(lon - (180 / pi) * (meter / 6378137) / cos(lat1))
lat2 <- as.numeric(lat + (180 / pi) * (meter / 6378137))
lon2 <-
as.numeric(lon + (180 / pi) * (meter / 6378137) / cos(lat2))
bb <- c(lat1, lon1, lat2, lon2)
bbstring <- paste(bb, collapse = ",")
vv <- "residential"
q1 <-
paste0('  way["highway"="', vv, '"](', bbstring, ');', collapse = '\n')
qq <-
paste0('[out:xml][timeout:25]; \n( \n',
q1,
'); \nout body; \n>; \nout skel qt;')
oo <- overpass_query(qq)
return(oo)
}
check_residental_coverage <- function(lat, lon, meter) {
lat1 <- as.numeric(lat - (180 / pi) * (meter / 6378137))
lon1 <-
as.numeric(lon - (180 / pi) * (meter / 6378137) / cos(lat1))
lat2 <- as.numeric(lat + (180 / pi) * (meter / 6378137))
lon2 <-
as.numeric(lon + (180 / pi) * (meter / 6378137) / cos(lat2))
bb <- c(lat1, lon1, lat2, lon2)
bbstring <- paste(bb, collapse = ",")
vv <- "residential"
q1 <-
paste0('  way["highway"="', vv, '"](', bbstring, ');', collapse = '\n')
qq <-
paste0('[out:xml][timeout:25]; \n( \n',
q1,
'); \nout body; \n>; \nout skel qt;')
oo <- overpass_query(qq)
if (is.null(oo)) {
rt <- 0
} else {
rt <- (length(oo@data$highway) / meter) * 10
}
return(rt)
}
check_residental_coverage(session_geo$lat[1], session_geo$lon[1], 1000)
oo <- check_oo(session_geo$lat[3], session_geo$lon[3], 5000)
rm.packages("overpass")
remove.packages("overpass")
devtools::install_github("hrbrmstr/overpass")
remove.packages("overpass")
remove.packages("overpass")
devtools::install_github("hrbrmstr/overpass")
#devtools::install_github("hrbrmstr/overpass")
library(overpass)
#devtools::install_github("hrbrmstr/overpass")
library(overpass)
library(osmdata)
library(sp)
session_geo <- vroom("data/session_geo.csv")
#devtools::install_github("hrbrmstr/overpass")
library(overpass)
library(sp)
library(vroom)
session_geo <- vroom("data/session_geo.csv")
check_oo <- function(lat, lon, meter) {
lat1 <- as.numeric(lat - (180 / pi) * (meter / 6378137))
lon1 <-
as.numeric(lon - (180 / pi) * (meter / 6378137) / cos(lat1))
lat2 <- as.numeric(lat + (180 / pi) * (meter / 6378137))
lon2 <-
as.numeric(lon + (180 / pi) * (meter / 6378137) / cos(lat2))
bb <- c(lat1, lon1, lat2, lon2)
bbstring <- paste(bb, collapse = ",")
vv <- "residential"
q1 <-
paste0('  way["highway"="', vv, '"](', bbstring, ');', collapse = '\n')
qq <-
paste0('[out:xml][timeout:25]; \n( \n',
q1,
'); \nout body; \n>; \nout skel qt;')
oo <- overpass_query(qq)
return(oo)
}
check_residental_coverage <- function(lat, lon, meter) {
lat1 <- as.numeric(lat - (180 / pi) * (meter / 6378137))
lon1 <-
as.numeric(lon - (180 / pi) * (meter / 6378137) / cos(lat1))
lat2 <- as.numeric(lat + (180 / pi) * (meter / 6378137))
lon2 <-
as.numeric(lon + (180 / pi) * (meter / 6378137) / cos(lat2))
bb <- c(lat1, lon1, lat2, lon2)
bbstring <- paste(bb, collapse = ",")
vv <- "residential"
q1 <-
paste0('  way["highway"="', vv, '"](', bbstring, ');', collapse = '\n')
qq <-
paste0('[out:xml][timeout:25]; \n( \n',
q1,
'); \nout body; \n>; \nout skel qt;')
oo <- overpass_query(qq)
if (is.null(oo)) {
rt <- 0
} else {
rt <- (length(oo@data$highway) / meter) * 10
}
return(rt)
}
check_residental_coverage(session_geo$lat[1], session_geo$lon[1], 1000)
check_residental_coverage(session_geo$lat[200], session_geo$lon[200], 1000)
check_residental_coverage <- function(lat, lon, meter) {
lat1 <- as.numeric(lat - (180 / pi) * (meter / 6378137))
lon1 <-
as.numeric(lon - (180 / pi) * (meter / 6378137) / cos(lat1))
lat2 <- as.numeric(lat + (180 / pi) * (meter / 6378137))
lon2 <-
as.numeric(lon + (180 / pi) * (meter / 6378137) / cos(lat2))
bb <- c(lat1, lon1, lat2, lon2)
bbstring <- paste(bb, collapse = ",")
vv <- "residential"
q1 <-
paste0('  way["highway"="', vv, '"](', bbstring, ');', collapse = '\n')
qq <-
paste0('[out:xml][timeout:25]; \n( \n',
q1,
'); \nout body; \n>; \nout skel qt;')
oo <- overpass_query(qq)
if (is.null(oo)) {
rt <- 0
} else {
rt <- (length(oo@data$highway) / meter) * 10
}
return(rt)
}
check_residental_coverage(session_geo$lat[250], session_geo$lon[250], 1000)
check_residental_coverage(session_geo$lat[250], session_geo$lon[250], 1000)
oo <- check_oo(session_geo$lat[3], session_geo$lon[3], 5000)
check_residental_coverage(session_geo$lat[250], session_geo$lon[1], 1000)
#devtools::install_github("hrbrmstr/overpass")
library(overpass)
#devtools::install_github("hrbrmstr/overpass")
library(overpass)
library(osmdata)
library(osmdata)
library(sp)
session_geo <- vroom("data/session_geo.csv")
check_oo <- function(lat, lon, meter) {
lat1 <- as.numeric(lat - (180 / pi) * (meter / 6378137))
lon1 <-
as.numeric(lon - (180 / pi) * (meter / 6378137) / cos(lat1))
lat2 <- as.numeric(lat + (180 / pi) * (meter / 6378137))
lon2 <-
as.numeric(lon + (180 / pi) * (meter / 6378137) / cos(lat2))
bb <- c(lat1, lon1, lat2, lon2)
bbstring <- paste(bb, collapse = ",")
vv <- "residential"
q1 <-
paste0('  way["highway"="', vv, '"](', bbstring, ');', collapse = '\n')
qq <-
paste0('[out:xml][timeout:25]; \n( \n',
q1,
'); \nout body; \n>; \nout skel qt;')
oo <- overpass_query(qq)
return(oo)
}
check_residental_coverage <- function(lat, lon, meter) {
lat1 <- as.numeric(lat - (180 / pi) * (meter / 6378137))
lon1 <-
as.numeric(lon - (180 / pi) * (meter / 6378137) / cos(lat1))
lat2 <- as.numeric(lat + (180 / pi) * (meter / 6378137))
lon2 <-
as.numeric(lon + (180 / pi) * (meter / 6378137) / cos(lat2))
bb <- c(lat1, lon1, lat2, lon2)
bbstring <- paste(bb, collapse = ",")
vv <- "residential"
q1 <-
paste0('  way["highway"="', vv, '"](', bbstring, ');', collapse = '\n')
qq <-
paste0('[out:xml][timeout:25]; \n( \n',
q1,
'); \nout body; \n>; \nout skel qt;')
oo <- overpass_query(qq)
if (is.null(oo)) {
rt <- 0
} else {
rt <- (length(oo@data$highway) / meter) * 10
}
return(rt)
}
check_residental_coverage(session_geo$lat[250], session_geo$lon[1], 1000)
check_residental_coverage(session_geo$lat[250], session_geo$lon[1], 1000)
check_residental_coverage(session_geo$lat[250], session_geo$lon[3], 1000)
oo <- check_oo(session_geo$lat[3], session_geo$lon[3], 5000)
oo <- check_oo(session_geo$lat[3], session_geo$lon[3], 5000)
check_residental_coverage(session_geo$lat[250], session_geo$lon[250], 1000)
check_residental_coverage(session_geo$lat[255], session_geo$lon[255], 1000)
oo <- check_oo(session_geo$lat[255], session_geo$lon[255], 5000)
oo@data$tunnel[is.na(oo@data$tunnel)] <- "no"
plot(oo,
col = factor(oo@data$highway),
lty = (oo@data$tunnel == "yes") + 1)
oo <- check_oo(session_geo$lat[3], session_geo$lon[3], 5000)
oo <- check_oo(session_geo$lat[750], session_geo$lon[750], 5000)
oo@data$tunnel[is.na(oo@data$tunnel)] <- "no"
plot(oo,
col = factor(oo@data$highway),
lty = (oo@data$tunnel == "yes") + 1)
legend(
x = "right",
legend = unique(oo@data$highway),
col = unique(factor(oo@data$highway)),
lty = 1,
cex = 0.7
)
plot(oo,
col = factor(oo@data$highway),
lty = (oo@data$tunnel == "yes") + 1)
oo <- check_oo(session_geo$lat[750], session_geo$lon[750], 1000)
Sys.sleep(100)
oo <- check_oo(session_geo$lat[5555], session_geo$lon[5555], 5000)
session_geo <- vroom("data/session_geo.csv")
check_oo <- function(lat, lon, meter) {
lat1 <- as.numeric(lat - (180 / pi) * (meter / 6378137))
lon1 <-
as.numeric(lon - (180 / pi) * (meter / 6378137) / cos(lat1))
lat2 <- as.numeric(lat + (180 / pi) * (meter / 6378137))
lon2 <-
as.numeric(lon + (180 / pi) * (meter / 6378137) / cos(lat2))
bb <- c(lat1, lon1, lat2, lon2)
bbstring <- paste(bb, collapse = ",")
vv <- "residential"
q1 <-
paste0('  way["highway"="', vv, '"](', bbstring, ');', collapse = '\n')
qq <-
paste0('[out:xml][timeout:25]; \n( \n',
q1,
'); \nout body; \n>; \nout skel qt;')
Sys.sleep(20)
oo <- overpass_query(qq)
return(oo)
}
oo <- check_oo(session_geo$lat[5555], session_geo$lon[5555], 5000)
oo <- check_oo(session_geo$lat[5555], session_geo$lon[5555], 5000)
oo <- check_oo(session_geo$lat[5555], session_geo$lon[5555], 5000)
#devtools::install_github("hrbrmstr/overpass")
library(overpass)
#devtools::install_github("hrbrmstr/overpass")
library(overpass)
library(osmdata)
library(sp)
library(vroom)
session_geo <- vroom("data/session_geo.csv")
session_geo <- vroom("data/session_geo.csv")
check_oo <- function(lat, lon, meter) {
lat1 <- as.numeric(lat - (180 / pi) * (meter / 6378137))
lon1 <-
as.numeric(lon - (180 / pi) * (meter / 6378137) / cos(lat1))
lat2 <- as.numeric(lat + (180 / pi) * (meter / 6378137))
lon2 <-
as.numeric(lon + (180 / pi) * (meter / 6378137) / cos(lat2))
bb <- c(lat1, lon1, lat2, lon2)
bbstring <- paste(bb, collapse = ",")
vv <- "residential"
q1 <-
paste0('  way["highway"="', vv, '"](', bbstring, ');', collapse = '\n')
qq <-
paste0('[out:xml][timeout:25]; \n( \n',
q1,
'); \nout body; \n>; \nout skel qt;')
Sys.sleep(20)
oo <- overpass_query(qq)
return(oo)
}
oo <- check_oo(session_geo$lat[5555], session_geo$lon[5555], 5000)
oo$highway
oo@data$tunnel[is.na(oo@data$tunnel)] <- "no"
plot(oo,
col = factor(oo@data$highway),
lty = (oo@data$tunnel == "yes") + 1)
oo@data$tunnel[is.na(oo@data$tunnel)] <- "no"
plot(oo,
col = factor(oo@data$highway),
lty = (oo@data$tunnel == "yes") + 1)
oo <- check_oo(session_geo$lat[3], session_geo$lon[3], 5000)
oo <- check_oo(session_geo$lat[3], session_geo$lon[3], 5000)
suppressMessages(library(foreach))
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
suppressMessages(library(mice))
suppressMessages(library(vroom))
suppressMessages(library(lubridate))
suppressMessages(library(tidyverse))
suppressMessages(library(lmtest))
suppressMessages(library(rgdal))
suppressMessages(library(sp))
suppressMessages(library(spdep))
suppressMessages(library(rgeos))
suppressMessages(library(RColorBrewer))
suppressMessages(library(classInt))
suppressMessages(library(dbscan))
suppressMessages(library(matrixStats))
suppressMessages(library(geosphere))
klienci <- vroom("data/klienci.csv")
session_geo <- vroom("data/session_geo.csv")
session_info <- vroom("data/session_info.csv")
klienci[, 1] <- c()
length(unique(klienci$klient_id))
length(unique(klienci$klient_id[klienci$czy_w_bazie_klientow == 1]))
library(foreach)
library(dplyr)
library(tidyr)
library(mice)
library(vroom)
library(lubridate)
library(tidyverse)
library(lmtest)
library(rgdal)
library(sp)
library(spdep)
library(rgeos)
library(RColorBrewer)
library(classInt)
library(dbscan)
library(geosphere)
source("PlotDbscanClustering.R")
klienci <- vroom("data/klienci.csv")
session_geo <- vroom("data/session_geo.csv")
session_info <- vroom("data/session_info.csv")
klienci[, 1] <- c()
densityplot(klienci$wynagrodzenie)
mean(klienci$wynagrodzenie)
mean(klienci$wynagrodzenie,na.rm= TRUE)
median(klienci$wynagrodzenie,na.rm= TRUE)
quantile(klienci$wynagrodzenie)
quantile(klienci$wynagrodzenie, na.rm = TRUE)
table(klienci$czy_kupil[klienci$wynagrodzenie < 6677.5])
table(klienci$czy_kupil[klienci$wynagrodzenie < 6677.5])
table(!klienci$czy_kupil[klienci$wynagrodzenie < 6677.5])
table(klienci$czy_kupil[klienci$wynagrodzenie < 6677.5])
table(klienci$czy_kupil[!klienci$wynagrodzenie < 6677.5])
table(klienci$czy_kupil[klienci$wynagrodzenie < 6677.5])
358 / 1112
table(klienci$czy_kupil[!klienci$wynagrodzenie < 6677.5])
686/3724
quantile(klienci$wynagrodzenie, na.rm = TRUE)
table(klienci$czy_kupil[klienci$wynagrodzenie > 6677.5 & klienci$wynagrodzenie < 7793])
table(klienci$czy_kupil[!klienci$wynagrodzenie > 6677.5 & klienci$wynagrodzenie < 7793])
358/1112
table(klienci$czy_kupil[klienci$wynagrodzenie > 6677.5 & klienci$wynagrodzenie < 7793])
table(klienci$czy_kupil[!klienci$wynagrodzenie > 6677.5 & klienci$wynagrodzenie < 7793])
quantile(klienci$wynagrodzenie, na.rm = TRUE)
table(klienci$czy_kupil[klienci$wynagrodzenie > 7793.0 & klienci$wynagrodzenie < 9546.5])
table(klienci$czy_kupil[!klienci$wynagrodzenie > 7793.0 & klienci$wynagrodzenie < 9546.5])
table(klienci$czy_kupil[klienci$wynagrodzenie > 7793.0 & klienci$wynagrodzenie < 9546.5])
table(klienci$czy_kupil[!klienci$wynagrodzenie > 7793.0 & klienci$wynagrodzenie < 9546.5])
table(klienci$czy_kupil[klienci$wynagrodzenie > 7793.0 & klienci$wynagrodzenie < 9546.5])
table(klienci$czy_kupil[!klienci$wynagrodzenie > 7793.0 & klienci$wynagrodzenie < 9546.5])
quantile(klienci$wynagrodzenie, na.rm = TRUE)
table(klienci$czy_kupil[klienci$wynagrodzenie > 9546.5])
table(klienci$czy_kupil[klienci$wynagrodzenie > 9546.5])
table(klienci$czy_kupil[!klienci$wynagrodzenie > 9546.5])
table(klienci$czy_kupil[klienci$wynagrodzenie > 9546.5])
table(klienci$czy_kupil[!klienci$wynagrodzenie > 9546.5])
table(klienci$czy_kupil[klienci$wynagrodzenie > 9546.5])
table(klienci$czy_kupil[klienci$wynagrodzenie > 9546.5])
table(klienci$czy_kupil[!klienci$wynagrodzenie > 9546.5])
table(klienci$czy_kupil[klienci$wynagrodzenie > 9546.5])
#Ze  wzgl
densityplot(klienci$wynagrodzenie)
#Delikatna prawostronna asymetria rozkadu wynagrodzen
quantile(klienci$wynagrodzenie, na.rm = TRUE)
table(klienci$czy_kupil[klienci$wynagrodzenie < 6677.5])
table(klienci$czy_kupil[!klienci$wynagrodzenie < 6677.5])
#Osoby z wynagrodzeniem poniżej 6677.5 (pierwszy kwartyl) czesciej kupuja uslugi premium niz pozostali
table(klienci$czy_kupil[klienci$wynagrodzenie > 6677.5 & klienci$wynagrodzenie < 7793])
table(klienci$czy_kupil[!klienci$wynagrodzenie > 6677.5 & klienci$wynagrodzenie < 7793])
#Osoby z wynagrodzeniem poniżej miedzy 6677.5 a 7793 nieco rzadziej kupuja uslugi premium niz pozostali
table(klienci$czy_kupil[klienci$wynagrodzenie > 7793.0 & klienci$wynagrodzenie < 9546.5])
table(klienci$czy_kupil[!klienci$wynagrodzenie > 7793.0 & klienci$wynagrodzenie < 9546.5])
#Osoby z wynagrodzeniem poniżej miedzy 7793 a 9546.5 nieco rzadziej kupuja uslugi premium niz pozostali
table(klienci$czy_kupil[klienci$wynagrodzenie > 9546.5])
table(klienci$czy_kupil[!klienci$wynagrodzenie > 9546.5])
#Osoby z wynagrodzeniem powyzej 9546.5 nieco rzadziej kupuja uslugi premium niz pozostali
#Ciekawa zaleznosc -> osoby najmniej zarabiajace najczesciej kupuja uslugi premium
#8.	Czy klienci korzystajÄ… z aplikacji w jednym miejscu, czy moĹĽe w wiÄ™kszej liczbie miejsc? Jaki jest Ĺ›redni rozrzut odlegĹ‚oĹ›ci w wykorzystaniu aplikacji?
for (i in 1:length(klienci$klient_id)) {
klienci$nloc[i] <-
length(unique(session[session$klient_id == klienci$klient_id[i],]$nuts3))
}
barplot(table(klienci$nloc))
table(klienci$nloc)
(392 + 35) / (3344 + 2229 + 392 + 35)
#8. Wiekszosc klientow korzysta z aplikacji w 1 jednostce NUTS3, 50% mniej klientow korzysta z aplikacji w 2 jednostkach NUTS3. Zaledwie 7% klientow korzysta z aplikacji w 3 lub wiekszej ilosci jednostek administracyjnych.
session_info
session_geo$lon[1]
session_geo$lat[1]
for (i in 1:length(klienci$klient_id)) {
max_session <- session[session$klient_id == klienci$klient_id[i],][which.min(unique(session[session$klient_id == klienci$klient_id[i],])$lon + unique(session[session$klient_id == klienci$klient_id[i],])$lat), ]
min_session <- session[session$klient_id == klienci$klient_id[i],][which.max(unique(session[session$klient_id == klienci$klient_id[i],])$lon + unique(session[session$klient_id == klienci$klient_id[i],])$lat), ]
klienci$max_min_dist[i] <- distm(c(min_session$lon,min_session$lat), c(max_session$lon,max_session$lat))
}
mean(klienci$max_min_dist)
#sredni rozrzut odlegosci w wykorzystaniu aplikacji przez klientow to 14349 m
densityplot(klienci$max_min_dist)
#brak wyraznej asymetrii rozkladu rozrzutu odlegosci w wykorzystaniu aplikacji przez klientow
#	Firma chce wdroĹĽyÄ‡ odpowiedniÄ… komunikacjÄ™ marketingowÄ… dla klientĂłw, u ktĂłrych moĹĽna stwierdziÄ‡ szanse
# kupna produktu premium. StwĂłrz model klasyfikacyjny, ktĂłrego celem jest przewidywanie ktĂłrzy klienci mogÄ… wykupiÄ‡ usĹ‚ugÄ™ premium. Jaka jest skutecznoĹ›Ä‡ takiego modelu? Jakie zmienne majÄ… najwiÄ™kszy wpĹ‚yw na decyzjÄ™ o kupnie?
library(dplyr)
library(vroom)
library(lubridate)
library(xgboost)
library(mice)
library(xgboost)
library(matrixStats)
library(Matrix)
source("VarSummary.R")
data <- readRDS("klienci.RDS")
VarSummary(data)
md.pattern(data)
imputed_data <- mice(data, m=5, maxit = 50, method = 'pmm', seed = 500)
densityplot(imputed_data)
dt <- complete(imputed_data,3)
onehotmatrix <- model.matrix(object = czy_kupil ~ ., data = dt)
temp_df <- data.frame(onehotmatrix)
temp_df <- temp_df %>% left_join(dt)
col.scale <- colMaxs(abs(onehotmatrix))
x.sc <- sweep(onehotmatrix, 2, col.scale, "/")
dtrain <- xgb.DMatrix(Matrix(x.sc, sparse = TRUE),
label = as.integer(temp$czy_kupil))
xgb.params <- list(
"booster" = "gbtree",
"eta" = 0.05,
"max_depth" = 4,
"subsample" = 0.632,
"colsample_bytree" = 0.4,
"colsample_bylevel" = 0.6,
"min_child_weight" = 1,
"gamma" = 0,
"lambda" = 0,
"alpha" = 0,
"objective" = "binary:logistic",
"eval_metric" = "auc",
"silent" = 1,
"nthread" = 4,
"num_parallel_tree" = 5
)
set.seed(2020)
cv.out <-
xgb.cv(
params = xgb.params,
data = dtrain,
nrounds = 1.5e3,
metrics = list('error'),
nfold = 5,
prediction = FALSE,
verbose = TRUE,
showsd = FALSE,
print.every.n = 10,
early.stop.round = 10,
maximize = TRUE
)
cv.out
xgb.model <- xgb.train(data = dtrain,
params = xgb.params,
nrounds = 500)
var.imp <- xgb.importance(colnames(x.sc), model = xgb.model) %>%
mutate(Feature = gsub('[0-9]+', '', Feature)) %>%
group_by(Feature) %>%
summarise(Importance = quantile(Gain, 0.9)) %>%
ungroup() %>%
arrange(desc(Importance)) %>%
mutate(Importance = round(100 * Importance / sum(Importance), 2))
